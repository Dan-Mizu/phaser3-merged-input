{"version":3,"sources":["webpack://MergedInput/webpack/universalModuleDefinition","webpack://MergedInput/webpack/bootstrap","webpack://MergedInput/./main.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","m","MergedInput","Phaser","Plugins","ScenePlugin","this","eventEmitter","systems","events","on","update","input","gamepad","once","thisGamepad","setupGamepad","gamepads","refreshPads","total","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","value","emit","err","return","keyboard","event","keyCode","Object","keys","Input","Keyboard","KeyCodes","find","key","playerIndex","getPlayerIndexFromKey","getPlayer","interaction","device","mouse","disableContextMenu","pointer","pointerMove","pointerDown","pointerUp","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","players","thisPlayer","buffer","pressed","BEARING","BEARING_DEGREES","ANGLE","direction","mapDirectionsToBearing","BEARING_LAST","DEGREES","parseFloat","mapBearingToDegrees","DEGREES_LAST","direction_secondary","checkKeyboardInput","checkGamepadInput","checkPointerInput","gamepadButtonDown","gamepadButtonUp","id","player","index","action","addPlayer","_typeof","Number","isInteger","push","setupControls","length","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","thisKey","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","controls","UP","DOWN","LEFT","RIGHT","buttons","M1","M2","M3","M4","M5","position","i","last","arguments","append","includes","addKey","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_step5","_iterator5","entries","_step5$value","_slicedToArray","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_step6","_iterator6","thisValue","isDown","JustDown","state","JustUp","_iteratorNormalCompletion7","_didIteratorError7","_iteratorError7","_step7","_iterator7","_step7$value","_iteratorNormalCompletion8","_didIteratorError8","_iteratorError8","_step8","_iterator8","button","pad","_iteratorNormalCompletion9","_didIteratorError9","_iteratorError9","_step9","_iterator9","leftStick","y","Math","abs","up","down","x","left","right","rightStick","b","threshold","distance","getBearingFromAngle","angle","angleToPointer","Angle","Between","worldX","worldY","pointerDirection","pointerAngle","leftButtonDown","rightButtonDown","middleButtonDown","backButtonDown","forwardButtonDown","leftButtonReleased","rightButtonReleased","middleButtonReleased","backButtonReleased","forwardButtonReleased","numDirections","snap_interval","PI2","angleSnap","Snap","To","angleSnapDeg","RadToDeg","bearings","bearing","thisDirection","toUpperCase","directions","_this2","shutdown","scene","debug","axes","a","axis","getValue","ID","Index","Buttons","Axes","_iteratorNormalCompletion10","_didIteratorError10","_iteratorError10","_step10","_iterator10","pluginManager","_classCallCheck","_this","_possibleConstructorReturn","__proto__","getPrototypeOf","call","-180","-168.75","-157.5","-146.25","-135","-123.75","-112.5","-101.25","-90","-78.75","-67.5","-56.25","-45","-33.75","-22.5","-11.25","0","11.25","22.5","33.75","45","56.25","67.5","78.75","90","101.25","112.5","123.75","135","146.25","157.5","168.75","180","c","d","name","getter","o","defineProperty","enumerable","get","r","toStringTag","t","mode","__esModule","ns","create","bind","n","object","property","prototype","hasOwnProperty","p","s","moduleId","l","modules"],"mappings":"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","file":"MergedInput.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"MergedInput\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"MergedInput\"] = factory();\n\telse\n\t\troot[\"MergedInput\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","export default class MergedInput extends Phaser.Plugins.ScenePlugin {\n\n    /**\n     * The Merged Input plugin is designed to run in the background and handle input.\n     * Upon detecting a keypress or gamepad interaction, the plugin will update a player object and emit global events.\n     *\n     * @extends Phaser.Scene\n     * @param {*} scene\n     * @param {*} pluginManager\n     */\n    constructor(scene, pluginManager) {\n        super(scene, pluginManager);\n        this.scene = scene;\n\n        // Players\n        this.players = [];\n        // Gamepads\n        this.gamepads = [];\n        // Keys object to store Phaser key objects. We'll check these during update\n        this.keys = {};\n\n        this.bearings = {\n            '-180': 'W',\n            '-168.75': 'WBN',\n            '-157.5': 'WNW',\n            '-146.25': 'NWBW',\n            '-135': 'NW',\n            '-123.75': 'NWBN',\n            '-112.5': 'NNW',\n            '-101.25': 'NBW',\n            '-90': 'N',\n            '-78.75': 'NBE',\n            '-67.5': 'NNE',\n            '-56.25': 'NEBN',\n            '-45': 'NE',\n            '-33.75': 'NEBE',\n            '-22.5': 'EBE',\n            '-11.25': 'EBN',\n            '0': 'E',\n            '11.25': 'EBS',\n            '22.5': 'ESE',\n            '33.75': 'SEBE',\n            '45': 'SE',\n            '56.25': 'SEBS',\n            '67.5': 'SSE',\n            '78.75': 'SBE',\n            '90': 'S',\n            '101.25': 'SBW',\n            '112.5': 'SSW',\n            '123.75': 'SWBS',\n            '135': 'SW',\n            '146.25': 'SWBW',\n            '157.5': 'WSW',\n            '168.75': 'WBS',\n            '180': 'W'\n        };\n    }\n\n    boot() {\n        this.eventEmitter = this.systems.events;\n        this.eventEmitter.on('update', this.update, this);\n\n        // Gamepad\n        if (typeof this.systems.input.gamepad !== 'undefined') {\n            this.systems.input.gamepad.once('connected', function (thisGamepad) {\n                this.setupGamepad(thisGamepad)\n            }, this);\n            this.gamepads = this.systems.input.gamepad.gamepads;\n\n            // Check to see if the gamepad has already been setup by the browser\n            this.systems.input.gamepad.refreshPads();\n            if (this.systems.input.gamepad.total) {\n                for (let thisGamepad of this.systems.input.gamepad.gamepads) {\n                    this.systems.input.gamepad.emit('connected', thisGamepad);\n                }\n            }\n        }\n\n        // Keyboard\n        this.systems.input.keyboard.on('keydown', function (event){\n            let keyCode = Object.keys(Phaser.Input.Keyboard.KeyCodes).find(key => Phaser.Input.Keyboard.KeyCodes[key] === event.keyCode);\n            let playerIndex = this.getPlayerIndexFromKey(keyCode);\n            if (playerIndex > -1) {\n                this.getPlayer(playerIndex).interaction.device = 'keyboard';\n            }\n        }, this);\n        this.systems.input.keyboard.on('keyup', function (){\n            let keyCode = Object.keys(Phaser.Input.Keyboard.KeyCodes).find(key => Phaser.Input.Keyboard.KeyCodes[key] === event.keyCode);\n            let playerIndex = this.getPlayerIndexFromKey(keyCode);\n            if (playerIndex > -1) {\n                this.getPlayer(playerIndex).interaction.device = 'keyboard';\n            }\n        }, this);\n\n\n        // Pointer\n        this.systems.input.mouse.disableContextMenu();\n\n        this.systems.input.on('pointermove', function (pointer) {\n            this.pointerMove(pointer);\n        }, this);\n\n        this.systems.input.on('pointerdown', function (pointer) {\n            this.pointerDown(pointer);\n        }, this);\n\n        this.systems.input.on('pointerup', function (pointer) {\n            this.pointerUp(pointer);\n        }, this);\n    }\n\n    update() {\n        // Loop through players and manage buffered input\n        for (let thisPlayer of this.players) {\n            if (thisPlayer.interaction.buffer == '') {\n                thisPlayer.interaction.pressed = '';\n            }\n            if (thisPlayer.interaction.pressed != '') {\n                thisPlayer.interaction.buffer = '';\n            }\n\n            // If the pointer hasn't moved, and the scene has changed, this can end up as undefined\n            thisPlayer.pointer.BEARING                  = typeof thisPlayer.pointer.BEARING != 'undefined' ? thisPlayer.pointer.BEARING : '';\n            thisPlayer.pointer.BEARING_DEGREES          = typeof thisPlayer.pointer.BEARING_DEGREES != 'undefined' ? thisPlayer.pointer.BEARING_DEGREES : '';\n            thisPlayer.pointer.ANGLE                    = typeof thisPlayer.pointer.ANGLE != 'undefined' ? thisPlayer.pointer.ANGLE : '';\n\n\n            thisPlayer.direction.BEARING                = this.mapDirectionsToBearing(thisPlayer.direction);\n            thisPlayer.direction.BEARING_LAST           = thisPlayer.direction.BEARING != '' ? thisPlayer.direction.BEARING : thisPlayer.direction.BEARING_LAST;\n            thisPlayer.direction.DEGREES                = thisPlayer.direction.BEARING != '' ? parseFloat(this.mapBearingToDegrees(thisPlayer.direction.BEARING)) : 0;\n            thisPlayer.direction.DEGREES_LAST           = thisPlayer.direction.BEARING_LAST != '' ? parseFloat(this.mapBearingToDegrees(thisPlayer.direction.BEARING_LAST)) : 0;\n            thisPlayer.direction_secondary.BEARING      = this.mapDirectionsToBearing(thisPlayer.direction_secondary);\n            thisPlayer.direction_secondary.BEARING_LAST = thisPlayer.direction_secondary.BEARING != '' ? thisPlayer.direction_secondary.BEARING : thisPlayer.direction_secondary.BEARING_LAST;\n            thisPlayer.direction_secondary.DEGREES      = thisPlayer.direction_secondary.BEARING != '' ? parseFloat(this.mapBearingToDegrees(thisPlayer.direction_secondary.BEARING)) : 0;\n            thisPlayer.direction_secondary.DEGREES_LAST = thisPlayer.direction_secondary.BEARING_LAST != '' ? parseFloat(this.mapBearingToDegrees(thisPlayer.direction_secondary.BEARING_LAST)) : 0;\n        }\n\n        this.checkKeyboardInput();\n        this.checkGamepadInput();\n        this.checkPointerInput();\n    }\n\n    /**\n     * Set up the gamepad and associate with a player object\n     */\n    setupGamepad(thisGamepad) {\n        thisGamepad.on('down', this.gamepadButtonDown, this);\n        thisGamepad.on('up', this.gamepadButtonUp, this);\n        this.eventEmitter.emit('mergedInput', {device:'gamepad', id:thisGamepad.id, player:thisGamepad.index, action:'Connected'});\n        if (typeof this.players[thisGamepad.index] === 'undefined') {\n            this.addPlayer();\n        }\n        this.players[thisGamepad.index].gamepad = thisGamepad;\n    }\n\n    /**\n     * Add a new player object to the players array\n     * @param {number} index Player index - if a player object at this index already exists, it will be returned instead of creating a new player object\n     */\n    addPlayer(index) {\n        if (typeof Number.isInteger(index) && typeof this.players[index] !== 'undefined') {\n            return this.players[index];\n        }\n        else {\n            this.players.push(this.setupControls());\n            this.players[this.players.length-1].index = this.players.length-1;\n            return this.players[this.players.length-1];\n        }\n    }\n\n    /**\n     * Get player object\n     * @param {number} index Player index\n     */\n    getPlayer(index) {\n        return typeof this.players[index] !== 'undefined' ? this.players[index] : ''\n    }\n\n    getPlayerIndexFromKey(key) {\n        for (let thisPlayer of this.players) {\n            // Loop through all the keys assigned to this player\n            for (var thisKey in thisPlayer.keys) {\n                for (var thisValue of thisPlayer.keys[thisKey]) {\n                    if (thisValue == key) {\n                        return thisPlayer.index;\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Returns a struct to hold input control information\n     * Set up a struct for each player in the game\n     * Direction and Buttons contain the input from the devices\n     * The keys struct contains arrays of keyboard characters that will trigger the action\n     */\n    setupControls() {\n        let controls = {\n            'direction': {\n                'UP': 0,\n                'DOWN': 0,\n                'LEFT': 0,\n                'RIGHT': 0,\n                'BEARING': '',\n                'BEARING_LAST': '',\n                'DEGREES': 0,\n                'DEGREES_LAST': 0\n            },\n            'direction_secondary': {\n                'UP': 0,\n                'DOWN': 0,\n                'LEFT': 0,\n                'RIGHT': 0,\n                'BEARING': '',\n                'DEGREES': 0,\n                'BEARING_LAST': '',\n                'DEGREES_LAST': 0\n            },\n            'buttons': {},\n            'pointer': {\n                'M1': 0,\n                'M2': 0,\n                'M3': 0,\n                'M4': 0,\n                'M5': 0,\n                'BEARING': '',\n                'BEARING_DEGREES': 0,\n                'ANGLE': 0\n            },\n            'position': {},\n            'interaction': {},\n            'gamepad': {},\n            'keys': {\n                'UP': [],\n                'DOWN': [],\n                'LEFT': [],\n                'RIGHT': [],\n            }\n        }\n        for (let i=1; i<=16; i++) {\n            controls.buttons['B'+i] = 0;\n            controls.keys['B'+i] = [];\n        }\n\n        controls.interaction.buffer = '';\n        controls.interaction.pressed = '';\n        controls.interaction.last = '';\n        controls.interaction.device = '';\n\n        return controls;\n    }\n\n    // Keyboard functions\n\n    /**\n     * Define a key for a player/action combination\n     * @param {number} player The player on which we're defining a key\n     * @param {string} action The action to define\n     * @param {string} value The key to use\n     * @param {boolean} append When true, this key definition will be appended to the existing key(s) for this action\n     */\n    defineKey(player = 0, action, value, append = false) {\n        // Set up a new player if none defined\n        if (typeof this.players[player] === 'undefined') {\n            this.addPlayer();\n        }\n\n        if (['UP','DOWN','LEFT','RIGHT','B0','B1','B2','B3','B4','B5','B6','B7','B8','B9','B10','B11','B12','B13','B14','B15','B16'].includes(action)) {\n            if (append) {\n                this.players[player].keys[action].push([value]);\n            }\n            else {\n                this.players[player].keys[action] = [];\n                this.players[player].keys[action].push([value]);\n            }\n\n            this.keys[[value]] = this.systems.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes[value]);\n        }\n\n        return this;\n    }\n\n    /**\n     * Iterate through players and check for interaction with defined keys\n     */\n    checkKeyboardInput() {\n        // Loop through players and check for keypresses - use of 'entries()' gives us an index to use for the player\n        for (let [playerIndex, thisPlayer] of this.players.entries()) {\n            // Loop through all the keys assigned to this player\n            for (var thisKey in thisPlayer.keys) {\n                let action = 0;\n                for (var thisValue of thisPlayer.keys[thisKey]) {\n                    // Check if the key is down\n                    action = (this.keys[thisValue].isDown) ? 1 : action;\n\n                    // Emit events based on the key down and up values\n                    if(Phaser.Input.Keyboard.JustDown(this.keys[thisValue])) {\n                        this.eventEmitter.emit('mergedInput', {device:'keyboard', value:1, player:playerIndex, action:thisKey, state: 'DOWN'});\n                        // Update the last button state\n                        thisPlayer.interaction.pressed = thisKey;\n                        thisPlayer.interaction.buffer = thisKey;\n                        thisPlayer.interaction.last = thisKey;\n                    }\n                    if(Phaser.Input.Keyboard.JustUp(this.keys[thisValue])) {\n                        this.eventEmitter.emit('mergedInput', {device:'keyboard', value:1, player:playerIndex, action:thisKey, state: 'UP'});\n                    }\n                }\n\n                // Set the action in the player object\n                if (['UP','DOWN','LEFT','RIGHT'].includes(thisKey)) {\n                    thisPlayer.direction[thisKey] = action;\n                }\n                else {\n                    thisPlayer.buttons[thisKey] = action;\n                }\n\n                // Set the latest interaction flag\n                if (action == 1) {\n                    thisPlayer.interaction.device = 'keyboard';\n                }\n            }\n        }\n    }\n\n\n\n    /**\n     * Iterate through players and check for interaction with defined pointer buttons\n     */\n    checkPointerInput() {\n        // Loop through players and check for button presses - use of 'entries()' gives us an index to use for the player\n        for (let [playerIndex, thisPlayer] of this.players.entries()) {\n            // Loop through all the keys assigned to this player\n            for (var thisKey in thisPlayer.keys) {\n                for (var thisValue of thisPlayer.keys[thisKey]) { // Each definition for this key action\n                    if (['M1','M2','M3','M4','M5'].includes(thisValue[0])) {\n                        // Check to see if button is pressed (stored in P1, can't have two mice...)\n                        if (this.players[0].pointer[thisValue] == 1) {\n                            thisPlayer.buttons[thisKey] = 1;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n\n    // Gamepad functions\n\n    /**\n     * When a gamepad button is pressed down, this function will emit a mergedInput event in the global registry.\n     * The event contains a reference to the player assigned to the gamepad, and passes a mapped action and value\n     * @param {number} index Button index\n     * @param {number} value Button value\n     * @param {Phaser.Input.Gamepad.Button} button Phaser Button object\n     */\n    gamepadButtonDown(index, value, button){\n        this.players[button.pad.index].interaction.device = 'gamepad';\n\n        this.eventEmitter.emit('mergedInput', {device:'gamepad', value:value, player:button.pad.index, action:'B' + index, state: 'DOWN'});\n\n        // DPad mapping\n        if (index === 12) {\n            this.eventEmitter.emit('mergedInput', {device:'gamepad', value:1, player:button.pad.index, action:'UP', state: 'DOWN'});\n        }\n        if (index === 13) {\n            this.eventEmitter.emit('mergedInput', {device:'gamepad', value:1, player:button.pad.index, action:'DOWN', state: 'DOWN'});\n        }\n        if (index === 14) {\n            this.eventEmitter.emit('mergedInput', {device:'gamepad', value:1, player:button.pad.index, action:'LEFT', state: 'DOWN'});\n        }\n        if (index === 15) {\n            this.eventEmitter.emit('mergedInput', {device:'gamepad', value:1, player:button.pad.index, action:'RIGHT', state: 'DOWN'});\n        }\n\n        // Last button pressed\n        if (![12,13,14,15].includes(index)) {\n            // Update the last button state\n\n            this.players[button.pad.index].interaction.pressed = 'B' + index;\n            this.players[button.pad.index].interaction.last = 'B' + index;\n            this.players[button.pad.index].interaction.buffer = 'B' + index;\n        }\n    }\n\n    /**\n     * When a gamepad button is released, this function will emit a mergedInput event in the global registry.\n     * The event contains a reference to the player assigned to the gamepad, and passes a mapped action and value\n     * @param {number} index Button index\n     * @param {number} value Button value\n     * @param {Phaser.Input.Gamepad.Button} button Phaser Button object\n     */\n    gamepadButtonUp(index, value, button){\n        this.players[button.pad.index].interaction.device = 'gamepad';\n        this.eventEmitter.emit('mergedInput', {device:'gamepad', value:value, player:button.pad.index, action:'B' + index, state: 'UP'});\n        // DPad mapping\n        if (index === 12) {\n            this.eventEmitter.emit('mergedInput', {device:'gamepad', value:1, player:button.pad.index, action:'UP', state: 'UP'});\n        }\n        if (index === 13) {\n            this.eventEmitter.emit('mergedInput', {device:'gamepad', value:1, player:button.pad.index, action:'DOWN', state: 'UP'});\n        }\n        if (index === 14) {\n            this.eventEmitter.emit('mergedInput', {device:'gamepad', value:1, player:button.pad.index, action:'LEFT', state: 'UP'});\n        }\n        if (index === 15) {\n            this.eventEmitter.emit('mergedInput', {device:'gamepad', value:1, player:button.pad.index, action:'RIGHT', state: 'UP'});\n        }\n    }\n\n    /**\n     * Iterate through gamepads and handle interactions\n     */\n    checkGamepadInput() {\n        // Check for gamepad input\n        for (var thisGamepad of this.gamepads) {\n\n            // Directions\n            if (thisGamepad.leftStick.y < -0.5) {\n                this.players[thisGamepad.index].direction.UP = Math.abs(thisGamepad.leftStick.y)\n            }\n            else if (thisGamepad.leftStick.y > 0.5) {\n                this.players[thisGamepad.index].direction.DOWN = thisGamepad.leftStick.y\n            }\n            else if (this.players[thisGamepad.index].interaction.device === 'gamepad') {\n                // DPad\n                this.players[thisGamepad.index].direction.UP = thisGamepad.up ? 1 : 0;\n                this.players[thisGamepad.index].direction.DOWN = thisGamepad.down ? 1 : 0;\n            }\n\n            if (thisGamepad.leftStick.x < -0.5) {\n                this.players[thisGamepad.index].direction.LEFT = Math.abs(thisGamepad.leftStick.x)\n            }\n            else if (thisGamepad.leftStick.x > 0.5) {\n                this.players[thisGamepad.index].direction.RIGHT = thisGamepad.leftStick.x\n            }\n            else if (this.players[thisGamepad.index].interaction.device === 'gamepad') {\n                // DPad\n                this.players[thisGamepad.index].direction.LEFT = thisGamepad.left ? 1 : 0;\n                this.players[thisGamepad.index].direction.RIGHT = thisGamepad.right ? 1 : 0;\n            }\n\n            // Secondary\n            if (thisGamepad.rightStick.y < -0.5) {\n                this.players[thisGamepad.index].direction_secondary.UP = Math.abs(thisGamepad.rightStick.y)\n            }\n            else if (thisGamepad.rightStick.y > 0.5) {\n                this.players[thisGamepad.index].direction_secondary.DOWN = thisGamepad.rightStick.y\n            }\n            else {\n                this.players[thisGamepad.index].direction_secondary.UP = 0;\n                this.players[thisGamepad.index].direction_secondary.DOWN = 0;\n            }\n\n            if (thisGamepad.rightStick.x < -0.5) {\n                this.players[thisGamepad.index].direction_secondary.LEFT = Math.abs(thisGamepad.rightStick.x)\n            }\n            else if (thisGamepad.rightStick.x > 0.5) {\n                this.players[thisGamepad.index].direction_secondary.RIGHT = thisGamepad.rightStick.x\n            }\n            else {\n                this.players[thisGamepad.index].direction_secondary.LEFT = 0;\n                this.players[thisGamepad.index].direction_secondary.RIGHT = 0;\n            }\n\n            if (this.players[thisGamepad.index].interaction.device === 'gamepad') {\n                // Buttons\n                for (var b = 0; b < thisGamepad.buttons.length; b++) {\n                    let button = thisGamepad.buttons[b];\n                    this.players[thisGamepad.index].buttons['B' + b] = button.value;\n                }\n            }\n        }\n    }\n\n\n    /**\n     * Function to run on pointer move.\n     * @param {*} pointer - The pointer object\n     */\n    pointerMove(pointer, threshold) {\n        var threshold = threshold || 0;\n        if (pointer.distance > threshold) {\n            let pointerDirection = this.getBearingFromAngle(pointer.angle, 8);\n            // this.players[0].direction_secondary = this.mapBearingToDirections(pointerDirection);\n\n            // If we've been given a player position, return bearings and angles\n            if (typeof this.players[0] !== 'undefined' && this.players[0].position.x !== 'undefined') {\n                let position            = this.players[0].position;\n                let angleToPointer      = Phaser.Math.Angle.Between(position.x, position.y, pointer.worldX, pointer.worldY);\n                let pointerDirection    = this.getBearingFromAngle(angleToPointer, 8);\n                let pointerAngle        = this.mapBearingToDegrees(pointerDirection);\n\n                this.players[0].pointer.BEARING         = pointerDirection;\n                this.players[0].pointer.ANGLE           = angleToPointer;\n                this.players[0].pointer.BEARING_DEGREES = pointerAngle;\n            }\n        }\n    }\n\n\n    /**\n     * Function to run on pointer down. Indicates that Mx has been pressed, which should be listened to by the player object\n     * @param {*} pointer - The pointer object\n     */\n    pointerDown(pointer) {\n        let action = '';\n        this.players[0].interaction.device = 'pointer';\n        if (pointer.leftButtonDown()) {\n            action = 'M1';\n        }\n        if (pointer.rightButtonDown()) {\n            action = 'M2';\n        }\n        if (pointer.middleButtonDown()) {\n            action = 'M3';\n        }\n        if (pointer.backButtonDown()) {\n            action = 'M4';\n        }\n        if (pointer.forwardButtonDown()) {\n            action = 'M5';\n        }\n\n        this.eventEmitter.emit('mergedInput', {device:'pointer', value:1, player:0, action:action, state: 'DOWN'});\n\n        this.players[0].pointer[action] = 1;\n\n        // Update the last button state\n        this.players[0].interaction.pressed = action;\n        this.players[0].interaction.last = action;\n        this.players[0].interaction.buffer = action;\n    }\n\n\n    /**\n     * Function to run on pointer up. Indicates that Mx has been released, which should be listened to by the player object\n     * @param {*} pointer - The pointer object\n     */\n    pointerUp(pointer) {\n        let action = '';\n        if (pointer.leftButtonReleased()) {\n            action = 'M1';\n        }\n        if (pointer.rightButtonReleased()) {\n            action = 'M2';\n        }\n        if (pointer.middleButtonReleased()) {\n            action = 'M3';\n        }\n        if (pointer.backButtonReleased()) {\n            action = 'M4';\n        }\n        if (pointer.forwardButtonReleased()) {\n            action = 'M5';\n        }\n\n        this.eventEmitter.emit('mergedInput', {device:'pointer', value:1, player:0, action:action, state: 'UP'});\n\n        this.players[0].pointer[action] = 0;\n    }\n\n\n    /**\n     * Get the bearing from a given angle\n     * @param {float} angle - Angle to use\n     * @param {number} numDirections - Number of possible directions (e.g. 4 for N/S/E/W)\n     */\n    getBearingFromAngle(angle, numDirections, threshold) {\n        var numDirections = numDirections || 8;\n\n        var snap_interval = Phaser.Math.PI2 / numDirections;\n\n        var angleSnap       = Phaser.Math.Snap.To(angle, snap_interval);\n        var angleSnapDeg    = Phaser.Math.RadToDeg(angleSnap);\n        var angleSnapDir    = this.bearings[angleSnapDeg];\n\n        return angleSnapDir;\n    }\n\n\n    /**\n     * Given a bearing, return a direction object containing boolean flags for the four directions\n     * @param {*} bearing\n     */\n    mapBearingToDirections(bearing) {\n        let thisDirection = {\n            'UP': 0,\n            'DOWN': 0,\n            'LEFT': 0,\n            'RIGHT': 0,\n            'BEARING': bearing.toUpperCase()\n        }\n\n        if (bearing.toUpperCase().includes('W')) {\n            thisDirection.LEFT = 1;\n        }\n        if (bearing.toUpperCase().includes('E')) {\n            thisDirection.RIGHT = 1;\n        }\n        if (bearing.toUpperCase().includes('S')) {\n            thisDirection.DOWN = 1;\n        }\n        if (bearing.toUpperCase().includes('N')) {\n            thisDirection.UP = 1;\n        }\n\n        return thisDirection;\n    }\n\n\n    /**\n     * Given a directions object, return the applicable bearing (8 way only)\n     * @param {*} directions\n     */\n    mapDirectionsToBearing(directions, threshold) {\n        var threshold = threshold || -.5\n        if (directions.UP && !(directions.LEFT || directions.RIGHT)) {\n            return 'N';\n        }\n        if (directions.RIGHT && directions.UP) {\n            return 'NE';\n        }\n        if (directions.RIGHT && !(directions.UP || directions.DOWN)) {\n            return 'E';\n        }\n        if (directions.RIGHT && directions.DOWN) {\n            return 'SE';\n        }\n        if (directions.DOWN && !(directions.LEFT || directions.RIGHT)) {\n            return 'S';\n        }\n        if (directions.LEFT && directions.DOWN) {\n            return 'SW';\n        }\n        if (directions.LEFT && !(directions.UP || directions.DOWN)) {\n            return 'W';\n        }\n        if (directions.LEFT && directions.UP) {\n            return 'NW';\n        }\n        return '';\n    }\n\n    /**\n     * Given a bearing, return the snapped angle in degrees\n     * @param {*} bearing\n     */\n    mapBearingToDegrees(bearing) {\n        if (bearing != '') {\n            return Object.keys(this.bearings).find(key => this.bearings[key] === bearing);\n        }\n        else {\n            return '';\n        }\n    }\n\n\n    destroy() {\n        this.shutdown();\n        this.scene = undefined;\n    }\n\n    /**\n     * Return debug object\n     */\n    debug() {\n        // Debug variables\n        var debug = {\n            'input' : {}\n        };\n        debug.input.gamepads = [];\n        for (var i = 0; i < this.gamepads.length; i++) {\n            let pad = this.gamepads[i];\n            let buttons = {};\n            let axes = {};\n\n            for (var b = 0; b < pad.buttons.length; b++) {\n                let button = pad.buttons[b];\n                buttons['B' + button.index] = button.value;\n            }\n\n            for (var a = 0; a < pad.axes.length; a++) {\n                let axis = pad.axes[a];\n                axes['A' + axis.index] = axis.getValue();\n            }\n\n            debug.input.gamepads.push({\n                'ID':       pad.id,\n                'Index':    pad.index,\n                'Buttons':  buttons,\n                'Axes':     axes\n            });\n        }\n\n        debug.players = [];\n        for (let thisPlayer of this.players) {\n            debug.players.push({\n                'interaction': thisPlayer.interaction,\n                'device': thisPlayer.device,\n                'buttons': thisPlayer.buttons,\n                'pointer': thisPlayer.pointer,\n                'direction': thisPlayer.direction,\n                'direction_secondary': thisPlayer.direction_secondary,\n                'keys': thisPlayer.keys\n            })\n        }\n\n        return debug;\n    }\n}\n"],"sourceRoot":""}